
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>后缀数组 | 刘兴的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="刘兴">
    

    
    <meta name="description" content="后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。可以说，在信息学竞赛中后缀数组比后缀树要更为实用。本文分两部分。第一部分介绍两种构造后缀数组的方法，重点介绍如何用简洁高效的代码实现，并对两种算法进行了比较。第二部分介绍后缀数组在各种类型题目中的具体应用。">
<meta property="og:type" content="article">
<meta property="og:title" content="后缀数组">
<meta property="og:url" content="http://pangjiuzala.github.io/2015/07/24/后缀数组/index.html">
<meta property="og:site_name" content="刘兴的博客">
<meta property="og:description" content="后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。可以说，在信息学竞赛中后缀数组比后缀树要更为实用。本文分两部分。第一部分介绍两种构造后缀数组的方法，重点介绍如何用简洁高效的代码实现，并对两种算法进行了比较。第二部分介绍后缀数组在各种类型题目中的具体应用。">
<meta property="og:updated_time" content="2015-07-24T02:26:00.219Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="后缀数组">
<meta name="twitter:description" content="后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。可以说，在信息学竞赛中后缀数组比后缀树要更为实用。本文分两部分。第一部分介绍两种构造后缀数组的方法，重点介绍如何用简洁高效的代码实现，并对两种算法进行了比较。第二部分介绍后缀数组在各种类型题目中的具体应用。">

    
    <link rel="alternative" href="https://github.com/search?q=pangjiuzala&type=Users" title="刘兴的博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="刘兴的博客" title="刘兴的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="刘兴的博客">刘兴的博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">文章列表</a></li>
					
					<li>
 					
					<form class="search" action="/search/index.html" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" autocomplete="off" name="q" maxlength="20" placeholder="搜索" />
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/24/后缀数组/" title="后缀数组" itemprop="url">后缀数组</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="刘兴" target="_blank" itemprop="author">刘兴</a>
		
  <p class="article-time">
    <time datetime="2015-07-24T02:05:51.000Z" itemprop="datePublished"> 发表于 2015-07-24</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#后缀数组的实现"><span class="toc-number">1.</span> <span class="toc-text">后缀数组的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本定义"><span class="toc-number">2.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#倍增算法"><span class="toc-number">3.</span> <span class="toc-text">倍增算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#具体实现："><span class="toc-number">4.</span> <span class="toc-text">具体实现：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DC3算法"><span class="toc-number">5.</span> <span class="toc-text">DC3算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#倍增算法与DC3算法的比较"><span class="toc-number">6.</span> <span class="toc-text">倍增算法与DC3算法的比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#后缀数组的应用"><span class="toc-number">7.</span> <span class="toc-text">后缀数组的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共前缀"><span class="toc-number">7.1.</span> <span class="toc-text">最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实现：-1"><span class="toc-number">7.2.</span> <span class="toc-text">具体实现：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单个字符串的相关问题"><span class="toc-number">8.</span> <span class="toc-text">单个字符串的相关问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子串的个数"><span class="toc-number">9.</span> <span class="toc-text">子串的个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#回文子串"><span class="toc-number">10.</span> <span class="toc-text">回文子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连续重复子串"><span class="toc-number">11.</span> <span class="toc-text">连续重复子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#公共子串"><span class="toc-number">12.</span> <span class="toc-text">公共子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子串的个数-1"><span class="toc-number">13.</span> <span class="toc-text">子串的个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个字符串的相关问题"><span class="toc-number">14.</span> <span class="toc-text">多个字符串的相关问题</span></a></li></ol>
		
		</div>
		
		<p>后缀数组是处理字符串的有力工具。后缀数组是后缀树的一个非常精巧的替代品，它比后缀树容易编程实现，能够实现后缀树的很多功能而时间复杂度也并不逊色，而且它比后缀树所占用的内存空间小很多。可以说，在信息学竞赛中后缀数组比后缀树要更为实用。本文分两部分。第一部分介绍两种构造后缀数组的方法，重点介绍如何用简洁高效的代码实现，并对两种算法进行了比较。第二部分介绍后缀数组在各种类型题目中的具体应用。<br><a id="more"></a></p>
<h1 id="后缀数组的实现">后缀数组的实现</h1><p>本节主要介绍后缀数组的两种实现方法：倍增算法和DC3算法，并对两种算法进行了比较。可能有的读者会认为这两种算法难以理解，即使理解了也难以用程序实现。本节针对这个问题，在介绍这两种算法的基础上，还给出了简洁高效的代码。其中倍增算法只有25行，DC3算法只有40行。</p>
<h1 id="基本定义">基本定义</h1><p>子串：字符串 S 的子串 r[i..j]，i≤j，表示 r 串中从 i 到 j 这一段，也就是顺次排列 r[i], r[i + 1], …, r[j]形成的字符串。</p>
<p>后缀：后缀是指从某个位置 i 开始到整个串末尾结束的一个特殊子串。字</p>
<p>后缀数组  符串  r 的从  第 i 个字符开始的后缀表示为  Suffix(i)，也就是Suffix(i) = r[i..len(r)]。</p>
<p>大小比较：关于字符串的大小比较，是指通常所说的“字典顺序”比较，也就是对于两个字符串 u、v，令 i 从 1 开始顺次比较 u[i]和 v[i]，如果u[i] = v[i]则令 i 加 1，否则若 u[i] &lt; v[i]则认为 u &lt; v，u[i] &gt; v[i]则认为 u &gt; v（也就是 v &lt; u），比较结束。如果 i &gt; len(u)或者 i &gt; len(v)仍比较不出结果，那么若  len(u) &lt; len(v)则认为  u &lt; v，若 len(u) = len(v)则认为  u = v，若len(u) &gt; len(v)则 u &gt; v。</p>
<p> 从字符串的大小比较的定义来看，S 的两个开头位置不同的后缀 u 和 v 进行比较的结果不可能是相等，因为 u = v 的必要条件 len(u) = len(v)在这里不可能满足。</p>
<p>后缀数组：后缀数组 SA 是一个一维数组，它保存 1..n 的某个排列SA[1]，SA[2]，……，SA[n]，并且保证Suffix(SA[i]) &lt; Suffix(SA[i + 1])，1≤i &lt; n。也就是将S 的 n 个后缀从小到大进行排序之后把排好序的后缀的开头位置顺次放入 SA中。</p>
<p>名次数组：名次数组Rank[i]保存的是 Suffix(i)在所有后缀中从小到大排列的“名次”。</p>
<p>简单的说，后缀数组是“排第几的是谁？”，名次数组是“你排第几？”。容易看出，后缀数组和名次数组为互逆运算。</p>
<p>设字符串的长度为n。为了方便比较大小，可以在字符串后面添加一个字符, 这个字符没有在前面的字符中出现过，而且比前面的字符都要小。在求出名次数组后，可以仅用O(1)的时间比较任意两个后缀的大小。在求出后缀数组或名次数组中的其中一个以后，便可以用O(n)的时间求出另外一个。任意两个后缀如果直接比较大小，最多需要比较字符n次，也就是说最迟在比较第n个字符时一定能分出“胜负”。</p>
<h1 id="倍增算法">倍增算法</h1><p>倍增算法的主要思路是：用倍增的方法对每个字符开始的长度为2k的子字符串进行排序，求出排名，即rank值。k从0开始，每次加1，当2k大于n以后，每个字符开始的长度为2k的子字符串便相当于所有的后缀。并且这些子字符串都一定已经比较出大小，即rank值中没有相同的值，那么此时的rank值就是最后的结果。每一次排序都利用上次长度为2k - 1的字符串的rank值，那么长度为2k的字符串就可以用两个长度为2k - 1的字符串的排名作为关键字表示，然后进行基数排序，便得出了长度为2k的字符串的rank值。以字符串“aabaaaab”为例，整个过程如图2所示。其中x、y是表示长度为2k的字符串的两个关键字。</p>
<h1 id="具体实现：">具体实现：</h1><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="delphi">int wa[maxn], wb[maxn], wv[maxn], ws[maxn];</span><br><span class="line"></span><br><span class="line">int cmp(int *r, int a, int b, int l)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;</span><br><span class="line">    return r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line">void da(int *r, int *sa, int n, int m)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j, p, *x = wa, *y = wb, *t;</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; m; i++) ws[i] = 0;</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; n; i++) ws[x[i] = r[i]]++;</span><br><span class="line"></span><br><span class="line">    for(i = 1; i &lt; m; i++) ws[i] += ws[i - 1];</span><br><span class="line"></span><br><span class="line">    for(i = n - 1; i &gt;= 0; i--) sa[--ws[x[i]]] = i;</span><br><span class="line"></span><br><span class="line">    for(j = 1, p = 1; p &lt; n; j *= 2, m = p)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">for(p = 0, i = n - j; i &lt; n; i++) y[p++] = i;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; n; i++) if(sa[i] &gt;= j) y[p++] = sa[i] - j;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; n; i++) wv[i] = x[y[i]];</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; m; i++) ws[i] = 0;</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; n; i++) ws[wv[i]]++;</span><br><span class="line"></span><br><span class="line">for(i = 1; i &lt; m; i++) ws[i] += ws[i - 1];</span><br><span class="line"></span><br><span class="line">for(i = n - 1; i &gt;= 0; i--) sa[--ws[wv[i]]] = y[i];</span><br><span class="line"></span><br><span class="line">for(t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i &lt; n; i++)</span><br><span class="line"></span><br><span class="line">    x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++;</span><br><span class="line"></span><br><span class="line">    &#125;</span></span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>待排序的字符串放在r数组中，从r[0]到r[n - 1]，长度为n，且最大值小于m。为了函数操作的方便，约定除r[n - 1]外所有的r[i]都大于0, r[n - 1] = 0。函数结束后，结果放在sa数组中，从sa[0]到sa[n - 1]。</p>
<p>函数的第一步，要对长度为1的字符串进行排序。一般来说，在字符串的题目中，r的最大值不会很大，所以这里使用了基数排序。如果 r的最大值很大，那么把这段代码改成快速排序。代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; m; <span class="built_in">i</span>++) ws<span class="matrix">[i]</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++) ws<span class="matrix">[x[i]</span> = r<span class="matrix">[i]</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt; m; <span class="built_in">i</span>++) ws<span class="matrix">[i]</span> += ws<span class="matrix">[i - <span class="number">1</span>]</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = n - <span class="number">1</span>; <span class="built_in">i</span> &gt;= <span class="number">0</span>; <span class="built_in">i</span>--) sa<span class="matrix">[--ws[x[i]</span>]] = <span class="built_in">i</span>;</span><br></pre></td></tr></table></figure>
<p>这里x数组保存的值相当于是rank值。下面的操作只是用x数组来比较字符的大小，所以没有必要求出当前真实的rank值。</p>
<p>接下来进行若干次基数排序，在实现的时候，这里有一个小优化。基数排序要分两次，第一次是对第二关键字排序，第二次是对第一关键字排序。对第二关键字排序的结果实际上可以利用上一次求得的sa直接算出，没有必要再算一次。代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = <span class="number">0</span>, <span class="built_in">i</span> = n - <span class="built_in">j</span>; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++) y<span class="matrix">[p++]</span> = <span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++) <span class="keyword">if</span>(sa<span class="matrix">[i]</span> &gt;= <span class="built_in">j</span>) y<span class="matrix">[p++]</span> = sa<span class="matrix">[i]</span> - <span class="built_in">j</span>;</span><br></pre></td></tr></table></figure>
<p>其中变量j是当前字符串的长度，数组y保存的是对第二关键字排序的结果。然后要对第一关键字进行排序，代码：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">for<span class="comment">(i = 0; i &lt; n; i++)</span> wv[i] = x[y[i]];</span><br><span class="line"></span><br><span class="line">for<span class="comment">(i = 0; i &lt; m; i++)</span> ws[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">for<span class="comment">(i = 0; i &lt; n; i++)</span> ws[wv[i]]++;</span><br><span class="line"></span><br><span class="line">for<span class="comment">(i = 1; i &lt; m; i++)</span> ws[i] += ws[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">for<span class="comment">(i = n - 1; i &gt;= 0; i--)</span> sa[--ws[wv[i]]] = y[i];</span><br></pre></td></tr></table></figure>
<p>这样便求出了新的sa值。在求出sa后，下一步是计算rank值。这里要注意的是，可能有多个字符串的rank值是相同的，所以必须比较两个字符串是否完全相同，y数组的值已经没有必要保存，为了节省空间，这里用y数组保存rank值。这里又有一个小优化，将x和y定义为指针类型，复制整个数组的操作可以用交换指针的值代替，不必将数组中值一个一个的复制。代码：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for<span class="comment">(t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i &lt; n; i++)</span></span><br><span class="line"></span><br><span class="line">    x[sa[i]] = cmp<span class="comment">(y, sa[i - 1], sa[i], j)</span> ? p - <span class="number">1</span> : p++;</span><br></pre></td></tr></table></figure>
<p>其中cmp函数的代码是：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l)</span></span><br><span class="line"></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a] == r[b] &amp;&amp; r[a + l] == r[b + l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到规定r[n - 1] = 0的好处，如果r[a] = r[b]，说明以r[a]或r[b]开头的长度为l的字符串肯定不包括字符r[n - 1]，所以调用变量r[a + l]和r[b + l]不会导致数组下标越界，这样就不需要做特殊判断。执行完上面的代码后，rank值保存在x数组中，而变量p的结果实际上就是不同的字符串的个数。这里可以加一个小优化，如果p等于n，那么函数可以结束。因为在当前长度的字符串中，已经没有相同的字符串，接下来的排序不会改变rank值。例如图1中的第四次排序，实际上是没有必要的。对上面的两段代码，循环的初始赋值和终止条件可以这样写：</p>
<p>   for(j = 1, p = 1; p &lt; n; j *= 2, m = p)<br>{<br>    …………<br>}</p>
<p>在第一次排序以后，rank数组中的最大值小于p，所以让m = p。</p>
<p>整个倍增算法基本写好，代码大约25行。</p>
<p>算法分析：</p>
<p>倍增算法的时间复杂度比较容易分析。每次基数排序的时间复杂度为O(n)，排序的次数决定于最长公共子串的长度，最坏情况下，排序次数为logn次，所以总的时间复杂度为O(nlogn)。</p>
<h1 id="DC3算法">DC3算法</h1><p>DC3算法分3步：</p>
<p>（１）、先将后缀分成两部分，然后对第一部分的后缀排序。</p>
<p>将后缀分成两部分，第一部分是后缀k（k模3不等于0），第二部分是后缀k（k模3等于0）。先对所有起始位置模3不等于0的后缀进行排序，即对suffix(1), suffix(2), suffix(4), suffix(5), suffix(7)……进行排序。做法是将suffix(1)和suffix(2)连接，如果这两个后缀的长度不是3的倍数，那先各自在末尾添0使得长度都变成3的倍数。然后每3个字符为一组，进行基数排序，将每组字符“合并”成一个新的字符。然后用递归的方法求这个新的字符串的后缀数组。如图3所示。在得到新的字符串的sa后，便可以计算出原字符</p>
<p>后缀数组  串所有起始位置模3不等于0的后缀的sa。要注意的是，原字符串必须以一个最小的且前面没有出现过的字符结尾，这样才能保证结果正确（请读者思考为什么）。</p>
<p>（２）、利用（1）的结果，对第二部分的后缀排序。</p>
<p>剩下的后缀是起始位置模3等于0的后缀，而这些后缀都可以看成是一个字符加上一个在（1）中已经求出rank的后缀，所以只要一次基数排序便可以求出剩下的后缀的sa。</p>
<p>（３）、将（1）和（2）的结果合并，即完成对所有后缀排序。</p>
<p>这个合并操作跟合并排序中的合并操作一样。每次需要比较两个后缀的大小。分两种情况考虑，第一种情况是suffix(3 <em> i)和suffix(3 </em> j + 1)的比较，可以把suffix(3 <em> i)和suffix(3 </em> j + 1)表示成：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">suffix<span class="comment">(3 * i)</span>   =  r[<span class="number">3</span> * i]   + suffix<span class="comment">(3 * i + 1)</span></span><br><span class="line"></span><br><span class="line"> suffix<span class="comment">(3 * j + 1)</span> =  r[<span class="number">3</span> * j + <span class="number">1</span>] + suffix<span class="comment">(3 * j + 2)</span></span><br></pre></td></tr></table></figure>
<p>   其中suffix(3 <em> i + 1)和suffix(3 </em> j + 2)的比较可以利用（2）的结果快速得到。第二种情况是suffix(3 <em> i)和suffix(3 </em> j + 2)的比较，可以把suffix(3 <em> i)和suffix(3 </em> j + 2)表示成：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">suffix(3 <span class="keyword">*</span> i)   = r[3 <span class="keyword">*</span> i]   + r[3 <span class="keyword">*</span> i + 1] + suffix(3 <span class="keyword">*</span> i + 2)</span><br><span class="line"></span><br><span class="line">   suffix(3 <span class="keyword">*</span> j + 2) = r[3 <span class="keyword">*</span> j + 2] + r[3 <span class="keyword">*</span> j + 3] + suffix(3 <span class="keyword">*</span> (j + 1) + 1)</span><br></pre></td></tr></table></figure>
<pre><code>同样的道理，<span class="function"><span class="title">suffix</span><span class="params">(<span class="number">3</span> * i + <span class="number">2</span>)</span></span>和<span class="function"><span class="title">suffix</span><span class="params">(<span class="number">3</span> * (j + <span class="number">1</span>)</span></span> + <span class="number">1</span>) 的比较可以利用（<span class="number">2</span>）的结果快速得到。所以每次的比较都可以高效的完成，这也是之前要每<span class="number">3</span>个字符合并，而不是每<span class="number">2</span>个字符合并的原因。

具体实现：
</code></pre><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">#define F(x) ((x)/<span class="number">3</span>+((x)%<span class="number">3</span>==<span class="number">1</span>?<span class="number">0</span>:tb))</span><br><span class="line"></span><br><span class="line">#define G(x) ((x)&lt;tb?(x)*<span class="number">3</span>+<span class="number">1</span>:((x)-tb)*<span class="number">3</span>+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    int wa[maxn], wb[maxn], wv[maxn], ws[maxn];</span><br><span class="line"></span><br><span class="line">int c0(int *r, int a, int b)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;</span><br><span class="line">    return r[a] == r[b] &amp;&amp; r[a + 1] == r[b + 1] &amp;&amp; r[a + 2] == r[b + 2];</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line">int c12(int k, int *r, int a, int b)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;</span><br><span class="line">    if(k == 2) return r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; c12(1, r, a + 1, b + 1);</span><br><span class="line"></span><br><span class="line">    else return r[a] &lt; r[b] || r[a] == r[b] &amp;&amp; wv[a + 1] &lt; wv[b + 1];</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line">void sort(int *r, int *a, int *b, int n, int m)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; n; i++) wv[i] = r[a[i]];</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; m; i++) ws[i] = 0;</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; n; i++) ws[wv[i]]++;</span><br><span class="line"></span><br><span class="line">    for(i = 1; i &lt; m; i++) ws[i] += ws[i - 1];</span><br><span class="line"></span><br><span class="line">    for(i = n - 1; i &gt;= 0; i--) b[--ws[wv[i]]] = a[i];</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line">void dc3(int *r, int *sa, int n, int m)</span><br><span class="line"></span><br><span class="line"><span class="comment">&#123;</span><br><span class="line"></span><br><span class="line">    int i, j, *rn = r + n, *san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p;</span><br><span class="line"></span><br><span class="line">    r[n] = r[n + 1] = 0;</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; n; i++) if(i % 3 != 0) wa[tbc++] = i;</span><br><span class="line"></span><br><span class="line">    sort(r + 2, wa, wb, tbc, m);</span><br><span class="line"></span><br><span class="line">    sort(r + 1, wb, wa, tbc, m);</span><br><span class="line"></span><br><span class="line">    sort(r, wa, wb, tbc, m);</span><br><span class="line"></span><br><span class="line">    for(p = 1, rn[F(wb[0])] = 0, i = 1; i &lt; tbc; i++)</span><br><span class="line"></span><br><span class="line">rn[F(wb[i])] = c0(r, wb[i - 1], wb[i]) ? p - 1 : p++;</span><br><span class="line"></span><br><span class="line">    if(p &lt; tbc) dc3(rn, san, tbc, p);</span><br><span class="line"> else for(i = 0; i &lt; tbc; i++) san[rn[i]] = i;</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; tbc; i++) if(san[i] &lt; tb) wb[ta++] = san[i] * 3;</span><br><span class="line"></span><br><span class="line">    if(n % 3 == 1) wb[ta++] = n - 1;</span><br><span class="line"></span><br><span class="line">    sort(r, wb, wa, ta, m);</span><br><span class="line"></span><br><span class="line">    for(i = 0; i &lt; tbc; i++) wv[wb[i] = G(san[i])] = i;</span><br><span class="line"></span><br><span class="line">    for(i = 0, j = 0, p = 0; i &lt; ta &amp;&amp; j &lt; tbc; p++)</span><br><span class="line"></span><br><span class="line">sa[p] = c12(wb[j] % 3, r, wa[i], wb[j]) ? wa[i++] : wb[j++];</span><br><span class="line"></span><br><span class="line">    for(; i &lt; ta; p++) sa[p] = wa[i++];</span><br><span class="line"></span><br><span class="line">    for(; j &lt; tbc; p++) sa[p] = wb[j++];</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>各个参数的作用和前面的倍增算法一样，不同的地方是r数组和sa数组的大小都要是3 * n，这为了方便下面的递归处理, 不用每次都申请新的内存空间。函数中用到的变量：</p>
<p>int i, j, <em>rn = r + n, </em>san = sa + n, ta = 0, tb = (n + 1) / 3, tbc = 0, p;</p>
<p>rn数组保存的是（1）中要递归处理的新字符串，san数组是新字符串的sa。变量ta表示起始位置模3为0的后缀个数，变量tb表示起始位置模3为1的后缀个数，已经直接算出。变量tbc表示起始位置模3为1或2的后缀个数。先按（1）中所说的用基数排序把3个字符“合并”成一个新的字符。为了方便操作，先将r[n]和r[n + 1]赋值为0。</p>
<p>代码：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">r[<span class="keyword">n</span>] = r[<span class="keyword">n</span> + 1] = 0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = 0; i &lt; <span class="keyword">n</span>; i++) <span class="keyword">if</span>(i % 3 != 0) wa[tbc++] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sort</span>(r + 2, wa, wb, tbc, <span class="keyword">m</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">sort</span>(r + 1, wb, wa, tbc, <span class="keyword">m</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">sort</span>(r, wa, wb, tbc, <span class="keyword">m</span>);</span><br></pre></td></tr></table></figure>
<p>其中sort函数的作用是进行基数排序。代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">void sort(<span class="keyword">int</span> *r, <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">for(i = <span class="number">0</span><span class="comment">; i &lt; n; i++) wv[i] = r[a[i]];</span></span><br><span class="line"></span><br><span class="line">for(i = <span class="number">0</span><span class="comment">; i &lt; m; i++) ws[i] = 0;</span></span><br><span class="line"></span><br><span class="line">for(i = <span class="number">0</span><span class="comment">; i &lt; n; i++) ws[wv[i]]++;</span></span><br><span class="line"></span><br><span class="line">for(i = <span class="number">1</span><span class="comment">; i &lt; m; i++) ws[i] += ws[i - 1];</span></span><br><span class="line"></span><br><span class="line">for(i = n - <span class="number">1</span><span class="comment">; i &gt;= 0; i--) b[--ws[wv[i]]] = a[i];</span></span><br><span class="line"></span><br><span class="line">return<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基数排序结束后，新的字符的排名保存在wb数组中。</p>
<p>跟倍增算法一样，在基数排序以后，求新的字符串时要判断两个字符组是否完全相同。代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">for<span class="list">(<span class="keyword">p</span> = <span class="number">1</span>, rn[F<span class="list">(<span class="keyword">wb</span>[<span class="number">0</span>])</span>] = <span class="number">0</span>, i = <span class="number">1</span><span class="comment">; i &lt; tbc; i++)</span></span><br><span class="line"></span><br><span class="line">    rn[F<span class="list">(<span class="keyword">wb</span>[i])</span>] = c0<span class="list">(<span class="keyword">r</span>, wb[i - <span class="number">1</span>], wb[i])</span> ? p - <span class="number">1</span> : p++<span class="comment">;</span></span></span><br></pre></td></tr></table></figure>
<p>其中F(x)是计算出原字符串的suffix(x)在新的字符串中的起始位置，c0函数是比较是否完全相同，在开头加一段代码：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">#define F<span class="list">(<span class="keyword">x</span>)</span> <span class="list">(<span class="list">(<span class="keyword">x</span>)</span>/3+<span class="list">(<span class="list">(<span class="keyword">x</span>)</span>%<span class="number">3</span>==1?<span class="number">0</span><span class="keyword">:tb</span>)</span>)</span></span><br><span class="line"></span><br><span class="line">inline int c0<span class="list">(<span class="keyword">int</span> <span class="variable">*r, int a, int b)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    return r[a] == r[b] &amp;&amp; r[a + 1] == r[b + 1] &amp;&amp; r[a + 2] == r[b + 2];</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>接下来是递归处理新的字符串，这里和倍增算法一样，可以加一个小优化，如果p等于tbc，那么说明在新的字符串中没有相同的字符，这样可以直接求出san数组，并不用递归处理。代码：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p &lt; tbc) dc3(rn, san, tbc, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; tbc; <span class="built_in">i</span>++) san<span class="matrix">[rn[i]</span>] = <span class="built_in">i</span>;</span><br></pre></td></tr></table></figure>
<p>然后是第（2）步，将所有起始位置模3等于0的后缀进行排序。其中对第二关键字的排序结果可以由新字符串的sa直接计算得到，没有必要再排一次。代码：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">i</span> = <span class="number">0</span>; <span class="keyword">i</span> &lt; tbc; <span class="keyword">i</span>++) <span class="keyword">if</span>(<span class="keyword">san</span>[<span class="keyword">i</span>] &lt; tb) wb[<span class="keyword">ta</span>++] = <span class="keyword">san</span>[<span class="keyword">i</span>] * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">n</span> % <span class="number">3</span> == <span class="number">1</span>) wb[<span class="keyword">ta</span>++] = <span class="keyword">n</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(<span class="keyword">r</span>, wb, <span class="keyword">wa</span>, <span class="keyword">ta</span>, <span class="keyword">m</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">i</span> = <span class="number">0</span>; <span class="keyword">i</span> &lt; tbc; <span class="keyword">i</span>++) <span class="keyword">wv</span>[wb[<span class="keyword">i</span>] = G(<span class="keyword">san</span>[<span class="keyword">i</span>])] = <span class="keyword">i</span>;</span><br></pre></td></tr></table></figure>
<p>要注意的是，如果n % 3 == 1，要特殊处理suffix(n - 1)，因为在san数组里并没有suffix(n)。G(x)是计算新字符串的suffix(x)在原字符串中的位置，和F(x)为互逆运算。在开头加一段：</p>
<figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="built_in">#</span>define G<span class="params">(x)</span> <span class="params">(<span class="params">(x)</span>&lt;tb?<span class="params">(x)</span>*<span class="number">3</span>+<span class="number">1</span>:<span class="params">(<span class="params">(x)</span>-tb)</span>*<span class="number">3</span>+<span class="number">2</span>)</span>。</span><br><span class="line"></span><br><span class="line">最后是第（<span class="number">3</span>）步，合并所有后缀的排序结果，保存在sa数组中。代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span><span class="params">(i = <span class="number">0</span>, j = <span class="number">0</span>, p = <span class="number">0</span>; i &lt; ta &amp;&amp; j &lt; tbc; p++)</span></span><br><span class="line"></span><br><span class="line">    sa[p] = c12<span class="params">(wb[j] % <span class="number">3</span>, r, wa[i], wb[j])</span> ? wa[i++] : wb[j++];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span><span class="params">(; i &lt; ta; p++)</span> sa[p] = wa[i++];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span><span class="params">(; j &lt; tbc; p++)</span> sa[p] = wb[j++];</span><br></pre></td></tr></table></figure>
<p> 其中c12函数是按（3）中所说的比较后缀大小的函数，k = 1是第一种情况，k = 2是第二种情况。代码：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"> int <span class="literal">c12</span>(int k, int *r, int a, int <span class="keyword">b)</span><br><span class="line"></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="preprocessor">if</span>(k == <span class="number">2</span>) return r[a] &lt; r[<span class="keyword">b] </span><span class="title">||</span> r[a] == r[<span class="keyword">b] </span>&amp;&amp; <span class="literal">c12</span>(<span class="number">1</span>, r, a + <span class="number">1</span>, <span class="keyword">b </span>+ <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">else</span> return r[a] &lt; r[<span class="keyword">b] </span><span class="title">||</span> r[a] == r[<span class="keyword">b] </span>&amp;&amp; wv[a + <span class="number">1</span>] &lt; wv[<span class="keyword">b </span>+ <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个DC3算法基本写好，代码大约40行。</p>
<p>算法分析：</p>
<p>假设这个算法的时间复杂度为f(n)。容易看出第（1）步排序的时间为O(n)（一般来说，m比较小，这里忽略不计）, 新的字符串的长度不超过2n / 3，求新字符串的sa的时间为f(2n / 3)，第（2）和第（3）步的时间都是O(n)。所以</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">f</span><span class="params">(n)</span></span> = <span class="function"><span class="title">O</span><span class="params">(n)</span></span> + <span class="function"><span class="title">f</span><span class="params">(<span class="number">2</span>n / <span class="number">3</span>)</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="title">f</span><span class="params">(n)</span></span> ≤ c×n + <span class="function"><span class="title">f</span><span class="params">(<span class="number">2</span>n / <span class="number">3</span>)</span></span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="title">f</span><span class="params">(n)</span></span> ≤ c×n + c×(<span class="number">2</span>n / <span class="number">3</span>) + c×(<span class="number">4</span>n / <span class="number">9</span>) + c×(<span class="number">8</span>n / <span class="number">27</span>) + …… ≤ <span class="number">3</span>c×n</span><br></pre></td></tr></table></figure>
<p>  所以    f(n) = O(n)<br>由此看出，DC3算法是一个优秀的线性算法。</p>
<h1 id="倍增算法与DC3算法的比较">倍增算法与DC3算法的比较</h1><p>从时间复杂度、空间复杂度、编程复杂度和实际效率等方面对倍增算法与<br> DC3算法进行比较。<br> 时间复杂度：</p>
<p>倍增算法的时间复杂度为O(nlogn)，DC3算法的时间复杂度为O(n)。从常数上看，DC3算法的常数要比倍增算法大。</p>
<p> 空间复杂度：</p>
<p>倍增算法和DC3算法的空间复杂度都是O(n)。按前面所讲的实现方法，倍增算法所需数组总大小为6n，DC3算法所需数组总大小为10n。</p>
<p>编程复杂度：</p>
<p>倍增算法的源程序长度为25行，DC3算法的源程序长度为40行。</p>
<p>实际效率：</p>
<p>测试环境：NOI - linux Pentium(R) 4 CPU 2.80GHz</p>
<p>N    倍增算法    DC3算法</p>
<p>200000    192    140</p>
<p>300000    367    244</p>
<p>500000    750    499</p>
<p>1000000    1693    1248</p>
<p>（不包括读入和输出的时间，单位：ms）</p>
<p>从表中可以看出，DC3算法在实际效率上还是有一定优势的。倍增算法容易实现，DC3算法效率比较高，但是实现起来比倍增算法复杂一些。对于不同的题目，应当根据数据规模的大小决定使用哪个算法。</p>
<h1 id="后缀数组的应用">后缀数组的应用</h1><p> 本节主要介绍后缀数组在各种类型的字符串问题中的应用。各题的原题请见附件二，参考代码请见附件三。</p>
<h2 id="最长公共前缀">最长公共前缀</h2><p> 这里先介绍后缀数组的一些性质。<br>height数组：定义height[i] = suffix(sa[i - 1])和suffix(sa[i])的最长公共前缀，也就是排名相邻的两个后缀的最长公共前缀。那么对于j和k，不妨设rank[j] &lt; rank[k], 则有以下性质：<br>suffix(j)和 suffix(k)的 最长公 共前 缀为 height[rank[j] + 1], height[rank[j] + 2], height[rank[j] + 3], … , height[rank[k]]中的最小值。<br>例如，字符串为“aabaaaab”，求后缀“abaaaab”和后缀“aaab”的最长公共前缀，如图4所示：<br> 那么应该如何高效的求出height值呢？<br>如果按height[2]，height[3]，……，height[n]的顺序计算，最坏情况下时间复杂度为 O(n)。这样做并没有利用字符串的性质。定义2<br> h[i] = height[rank[i]]，也就是suffix(i)和在它前一名的后缀的最长公共前缀。<br>h数组有以下性质：<br> h[i]≥h[i - 1] - 1<br>证明：<br>设suffix(k)是排在suffix(i - 1)前一名的后缀，则它们的最长公共前缀是h[i - 1]。那么suffix(k + 1)将排在suffix(i)的前面（这里要求h[i - 1] &gt; 1，如果h[i - 1]≤1，原式显然成立）并且suffix(k + 1)和suffix(i)的最长公共前缀是 h[i - 1] - 1，所以suffix(i)和在它前一名的后缀的最长公共前缀至少是h[i - 1] - 1。按照h[1], h[2], ……, h[n]的顺序计算, 并利用h数组的性质，时间复杂度可以降为O(n)。</p>
<h2 id="具体实现：-1">具体实现：</h2><p>实现的时候其实没有必要保存h数组，只须按照h[1], h[2], ……, h[n]的顺序计算即可。代码：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> rank[maxn], <span class="variable">height</span>[maxn];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">void</span> calheight(<span class="built_in">int</span> *r, <span class="built_in">int</span> *sa, <span class="built_in">int</span> n)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) rank[sa[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; <span class="variable">height</span>[rank[i++]] = k)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k ? k-- : <span class="number">0</span>, j = sa[rank[i] - <span class="number">1</span>]; r[i + k] == r[j + k]; k++);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例1：最长公共前缀</p>
<p>给定一个字符串，询问某两个后缀的最长公共前缀。</p>
<p>算法分析：</p>
<p>按照上面所说的做法，求两个后缀的最长公共前缀可以转化为求某个区间上的最小值。对于这个RMQ问题（如果对RMQ问题不熟悉，请阅读其他相关资料），可以用O(nlogn)的时间先预处理，以后每次回答询问的时间为O(1)。所以对于本问题，预处理时间为O(nlogn)，每次回答询问的时间为O(1)。如果RMQ问题用O(n)的时间预处理，那么本问题预处理的时间可以做到O(n)。</p>
<h1 id="单个字符串的相关问题">单个字符串的相关问题</h1><p>这类问题的一个常用做法是先求后缀数组和height数组，然后利用height数组进行求解。</p>
<p>重复子串：字符串R在字符串L中至少出现两次，则称R是L的重复子串。</p>
<p>例2：可重叠最长重复子串</p>
<p>给定一个字符串，求最长重复子串，这两个子串可以重叠。</p>
<p>算法分析：</p>
<p>这道题是后缀数组的一个简单应用。做法比较简单，只需要求height数组里的最大值即可。首先求最长重复子串，等价于求两个后缀的最长公共前缀的最大值。因为任意两个后缀的最长公共前缀都是height数组里某一段的最小值，那么这个值一定不大于height数组里的最大值。所以最长重复子串的长度就是height数组里的最大值。这个做法的时间复杂度为O(n)。</p>
<p>例3：不可重叠最长重复子串（pku1743）</p>
<p>给定一个字符串，求最长重复子串，这两个子串不能重叠。</p>
<p>算法分析：</p>
<p>这题比上一题稍复杂一点。先二分答案，把题目变成判定性问题：判断是否存在两个长度为k的子串是相同的，且不重叠。解决这个问题的关键还是利用height数组。把排序后的后缀分成若干组，其中每组的后缀之间的height值都不小于k。例如，字符串为“aabaaaab”，当k = 2时，后缀分成了4组<br>容易看出，有希望成为最长公共前缀不小于k的两个后缀一定在同一组。然后对于每组后缀，只须判断每个后缀的sa值的最大值和最小值之差是否不小于k。如果有一组满足，则说明存在，否则不存在。整个做法的时间复杂度为O(nlogn)。本题中利用height值对后缀进行分组的方法很常用，请读者认真体会。</p>
<p>例4：可重叠的k次最长重复子串（pku3261）</p>
<p>给定一个字符串，求至少出现k次的最长重复子串，这k个子串可以重叠。</p>
<p>算法分析：</p>
<p>这题的做法和上一题差不多，也是先二分答案，然后将后缀分成若干组。不同的是，这里要判断的是有没有一个组的后缀个数不小于k。如果有，那么存在k个相同的子串满足条件，否则不存在。这个做法的时间复杂度为O(nlogn)。</p>
<h1 id="子串的个数">子串的个数</h1><p>例5：不相同的子串的个数（spoj694, spoj705）</p>
<p>给定一个字符串，求不相同的子串的个数。</p>
<p>算法分析：</p>
<p>每个子串一定是某个后缀的前缀，那么原问题等价于求所有后缀之间的不相同的前缀的个数。如果所有的后缀按照 suffix(sa[1]), suffix(sa[2]), suffix(sa[3]), …… , suffix(sa[n])的顺序计算，不难发现，对于每一次新加进来的后缀suffix(sa[k]), 它将产生n - sa[k] + 1个新的前缀。但是其中有height[k]个是和前面的字符串的前缀是相同的。所以suffix(sa[k])将“贡献”出n - sa[k] + 1 - height[k]个不同的子串。累加后便是原问题的答案。这个做法的时间复杂度为O(n)。</p>
<h1 id="回文子串">回文子串</h1><p>回文子串：如果将字符串L的某个子字符串R反过来写后和原来的字符串R一样，则称字符串R是字符串L的回文子串。</p>
<p>例6：最长回文子串（ural1297）</p>
<p>给定一个字符串，求最长回文子串。</p>
<p>算法分析：</p>
<p>穷举每一位，然后计算以这个字符为中心的最长回文子串。注意这里要分两种情况，一是回文子串的长度为奇数，二是长度为偶数。两种情况都可以转化为求一个后缀和一个反过来写的后缀的最长公共前缀。具体的做法是：将整个字符串反过来写在原字符串后面，中间用一个特殊的字符隔开。这样就把问题变为了求这个新的字符串的某两个后缀的最长公共前缀。如图6所示。</p>
<p>这个做法的时间复杂度为O(nlogn)。如果RMQ问题用时间为O(n)的方法预处理，那么本题的时间复杂度可以降为O(n)。</p>
<h1 id="连续重复子串">连续重复子串</h1><p>连续重复串：如果一个字符串L是由某个字符串S重复R次而得到的，则称L是一个连续重复串。R是这个字符串的重复次数。</p>
<p>例7：连续重复子串(pku2406)</p>
<p>给定一个字符串L，已知这个字符串是由某个字符串S重复R次而得到的，求R的最大值。</p>
<p>算法分析：</p>
<p>做法比较简单，穷举字符串S的长度k，然后判断是否满足。判断的时候，先看字符串L的长度能否被k整除，再看suffix(1)和suffix(k + 1)的最长公共前缀是否等于n - k。在询问最长公共前缀的时候，suffix(1)是固定的，所以RMQ问题没有必要做所有的预处理，只需求出height数组中的每一个数到height[rank[1]]之间的最小值即可。整个做法的时间复杂度为O(n)。</p>
<p>例8：重复次数最多的连续重复子串(spoj687, pku3693)</p>
<p>给定一个字符串，求重复次数最多的连续重复子串。</p>
<p>算法分析：</p>
<p>先穷举长度L，然后求长度为L的子串最多能连续出现几次。首先连续出现1次是肯定可以的，所以这里只考虑至少2次的情况。假设在原字符串中连续出现2次，记这个子字符串为S，那么S肯定包括了字符r[0], r[L], r[L <em> 2], r[L </em> 3], ……中的某相邻的两个。所以只须看字符r[L <em>i]和r[L </em> (i + 1)]往前和往后各能匹配到多远，记这个总长度为K，那么这里连续出现了K / L + 1次。最后看最大值是多少。如图7所示。</p>
<p>穷举长度L的时间是n，每次计算的时间是n / L。所以整个做法的时间复杂度是O(n / 1 + n / 2 + n / 3 + …… +n / n) = O(nlogn)。</p>
<p> 两个字符串的相关问题</p>
<p> 这类问题的一个常用做法是，先连接这两个字符串，然后求后缀数组和height数组，再利用height数组进行求解。</p>
<h1 id="公共子串">公共子串</h1><p> 公共子串:<br> 如果字符串L同时出现在字符串A和字符串B中，则称字符串L是字符串A和字符串B的公共子串。</p>
<p> 例9：最长公共子串(pku2774, ural1517)</p>
<p> 给定两个字符串A和B，求最长公共子串。</p>
<p> 算法分析:</p>
<p> 字符串的任何一个子串都是这个字符串的某个后缀的前缀。求A和B的最长公共子串等价于求A的后缀和B的后缀的最长公共前缀的最大值。如果枚举A和B的所有的后缀，那么这样做显然效率低下。由于要计算A的后缀和B的后缀的最长公共前缀，所以先将第二个字符串写在第一个字符串后面，中间用一个没有出现过的字符隔开，再求这个新的字符串的后缀数组。观察一下，看看能不能从这个新的字符串的后缀数组中找到一些规律。以A = “aaaba”，B = “abaa”为例，如图8所示。</p>
<p>那么是不是所有的height值中的最大值就是答案呢？不一定！有可能这两个后缀是在同一个字符串中的，所以实际上只有当suffix(sa[i - 1])和</p>
<p>后缀数组  suffix(sa[i])不是同一个字符串中的两个后缀时，height[i]才是满足条件的。而这其中的最大值就是答案。记字符串A和字符串B的长度分别为 | A | 和 | B | 。求新的字符串的后缀数组和height数组的时间是O( | A | + | B | )，然后求排名相邻但原来不在同一个字符串中的两个后缀的height值的最大值，时间也是O( | A | + | B | )，所以整个做法的时间复杂度为O( | A | + | B | )。时间复杂度已经取到下限，由此看出，这是一个非常优秀的算法。</p>
<h1 id="子串的个数-1">子串的个数</h1><p>例10:<br>长度不小于k的公共子串的个数(pku3415)</p>
<p>给定两个字符串A和B，求长度不小于k的公共子串的个数（可以相同）。</p>
<p>样例1:</p>
<p>A = “xx”，B = “xx”，k = 1，长度不小于k的公共子串的个数是5。</p>
<p> 样例2:</p>
<p> A = “aababaa”，B = “abaabaa”，k = 2，长度不小于k的公共子串的个数是22。</p>
<p> 算法分析:</p>
<p> 基本思路是计算A的所有后缀和B的所有后缀之间的最长公共前缀的长度，把最长公共前缀长度不小于k的部分全部加起来。先将两个字符串连起来，中间用一个没有出现过的字符隔开。按height值分组后，接下来的工作便是快速的统计每组中后缀之间的最长公共前缀之和。扫描一遍，每遇到一个B的后缀就统计与前面的A的后缀能产生多少个长度不小于k的公共子串，这里A的后缀需要用一个单调的栈来高效的维护。然后对A也这样做一次。具体的细节留给读者思考。</p>
<h1 id="多个字符串的相关问题">多个字符串的相关问题</h1><p> 这类问题的一个常用做法是，先将所有的字符串连接起来，然后求后缀数组和height数组，再利用height数组进行求解。这中间可能需要二分答案。</p>
<p> 例11:<br> 不小于k个字符串中的最长子串(pku3294)</p>
<p> 给定n个字符串，求出现在不小于k个字符串中的最长子串。</p>
<p> 算法分析:</p>
<p> 将n个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，用和例3同样的方法将后缀分成若干组，判断每组的后缀是否出现在不小于k个的原串中。这个做法的时间复杂度为O(nlogn)。</p>
<p> 例12:<br> 每个字符串至少出现两次且不重叠的最长子串(spoj220)</p>
<p> 给定n个字符串，求在每个字符串中至少出现两次且不重叠的最长子串。</p>
<p> 算法分析:</p>
<p> 做法和上题大同小异，也是先将n个字符串连起来，中间用不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串中至少出现两次，并且在每个原来的字符串中，后缀的起始位置的最大值与最小值之差是否不小于当前答案（判断能否做到不重叠，如果题目中没有不重叠的要求，那么不用做此判断）。这个做法的时间复杂度为O(nlogn)。</p>
<p> 例13:<br> 出现或反转后出现在每个字符串中的最长子串(PKU3294)</p>
<p> 给定n个字符串，求出现或反转后出现在每个字符串中的最长子串。</p>
<p> 算法分析:</p>
<p> 这题不同的地方在于要判断是否在反转后的字符串中出现。其实这并没有加大题目的难度。只需要先将每个字符串都反过来写一遍，中间用一个互不相同的且没有出现在字符串中的字符隔开，再将n个字符串全部连起来，中间也是用一个互不相同的且没有出现在字符串中的字符隔开，求后缀数组。然后二分答案，再将后缀分组。判断的时候，要看是否有一组后缀在每个原来的字符串或反转后的字符串中出现。这个做法的时间复杂度为O(nlogn)。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	<div class="share-jiathis">
	  
<div class="jiathis_style_24x24">
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_googleplus"></a>
	<a class="jiathis_button_douban"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
    var jiathis_config={
    data_track_clickback:true,
    sm:"copy,renren,cqq",
    pic:"",
    summary:"",
    
  </script> 
<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=
" charset="utf-8"></script>      

	 </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2015/07/23/数据挖掘笔记/"  title="数据挖掘笔记">
 <strong>下一篇：</strong><br/> 
 <span>数据挖掘笔记
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/07/24/后缀数组/" data-title="后缀数组" data-url="http://pangjiuzala.github.io/2015/07/24/后缀数组/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#后缀数组的实现"><span class="toc-number">1.</span> <span class="toc-text">后缀数组的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本定义"><span class="toc-number">2.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#倍增算法"><span class="toc-number">3.</span> <span class="toc-text">倍增算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#具体实现："><span class="toc-number">4.</span> <span class="toc-text">具体实现：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DC3算法"><span class="toc-number">5.</span> <span class="toc-text">DC3算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#倍增算法与DC3算法的比较"><span class="toc-number">6.</span> <span class="toc-text">倍增算法与DC3算法的比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#后缀数组的应用"><span class="toc-number">7.</span> <span class="toc-text">后缀数组的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#最长公共前缀"><span class="toc-number">7.1.</span> <span class="toc-text">最长公共前缀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实现：-1"><span class="toc-number">7.2.</span> <span class="toc-text">具体实现：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#单个字符串的相关问题"><span class="toc-number">8.</span> <span class="toc-text">单个字符串的相关问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子串的个数"><span class="toc-number">9.</span> <span class="toc-text">子串的个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#回文子串"><span class="toc-number">10.</span> <span class="toc-text">回文子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#连续重复子串"><span class="toc-number">11.</span> <span class="toc-text">连续重复子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#公共子串"><span class="toc-number">12.</span> <span class="toc-text">公共子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#子串的个数-1"><span class="toc-number">13.</span> <span class="toc-text">子串的个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#多个字符串的相关问题"><span class="toc-number">14.</span> <span class="toc-text">多个字符串的相关问题</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/移动互联网/" title="移动互联网">移动互联网<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/数据挖掘/" title="数据挖掘">数据挖掘<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/物联网/" title="物联网">物联网<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/大数据/" title="大数据">大数据<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/云计算/" title="云计算">云计算<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C++">C++<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GC/" title="GC">GC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/openHAB/" title="openHAB">openHAB<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/网络爬虫/" title="网络爬虫">网络爬虫<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://weibo.com/jiayou087" target="_blank" title="刘兴的微博主页">微博</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/pangjiuzala" target="_blank" title="刘兴的CSDN博客">CSDN</a>
            
          </li>
        
    </ul>
</div>

  


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">17</span></li></ul>
  </div>


  <div class="rsspart">
	<a href="https://github.com/search?q=pangjiuzala&amp;type=Users" target="_blank" title="关注刘兴的github">关注</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello,I&#39;m from ZjuCs! <br/>
			The more you diligent, the more you lucky!</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Copyright@2015 Liuxing All rights reserved.
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>
<script type="text/javascript">

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"pangjiuzala"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'null', 'null');  
ga('send', 'pageview');
</script>



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Ffeafc504b70a541dd3845d467335f367' type='text/javascript'%3E%3C/script%3E"));
</script>



<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_null'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s23.cnzz.com/z_stat.php%3Fid%3Dnull' type='text/javascript'%3E%3C/script%3E"));</script>

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<script>
var option = {
  engineKey: '4ac092ad8d749fdc6293'
};
(function(w,d,t,u,n,s,e){
  s = d.createElement(t);
  s.src = u;
  s.async = 1;
  w[n] = function(r){
    w[n].opts = r;
  };
  e = d.getElementsByTagName(t)[0];
  e.parentNode.insertBefore(s, e);
})(window,document,'script','//tinysou-cdn.b0.upaiyun.com/ts.js','_ts');
_ts(option);
</script>

<!-- Tiny_search End -->

  </body>
</html>
